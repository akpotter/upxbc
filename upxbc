#! /usr/bin/python
# by pts@fazekas.hu at Sun Dec 31 19:21:00 CET 2017

import os
import os.path
import pipes
import struct
import subprocess
import sys
import zlib


def parse_struct(fields, data):
  values = struct.unpack('<' * (fields[0][1][0] not in '<>') + ''.join(f[1] for f in fields), data)
  return dict(zip((f[0] for f in fields), values))


def dump_struct(fields, data):
  format = '<' * (fields[0][1][0] not in '<>') + ''.join(f[1] for f in fields)
  values = struct.unpack(format, data)
  print '--- Header ' + format
  for (field_name, field_type), value in zip(fields, values):
    if isinstance(value, (int, long)):
      value = '0x%x' % value
    else:
      value = repr(value)
    print '%s = %s' % (field_name, value)
  print '---/Header'


def get_elf32_header(len_data, load_addr=0x8048000):
  # ELF 32-bit LSB  executable, Intel 80386, version 1 (GNU/Linux), statically linked, stripped.
  # Contains ELF EHDR and 1 PHDR (program header).
  if load_addr & 0xff:
    raise ValueError('load_addr not aligned.')  # What would break?
  return ''.join((  # 0x54 bytes.
      '\x7fELF\x01\x01\x01\x03\0\0\0\0\0\0\0\0\x02\0\x03\0\x01\0\0\0',
      struct.pack('<L', load_addr + 0x54),  # e_entry.
      '4\0\0\0\0\0\0\0\0\0\0\x004\0\x20\0\x01\0\x28\0\0\0\0\0\x01\0\0\0\0\0\0\0',
      # p_vaddr, p_paddr, p_filesz, p_memsz.
      struct.pack('<LLLL', load_addr, load_addr, len_data + 0x54, len_data + 0x54),
      '\x07\0\0\0\x01\0\0\0'))


def run_upx_elf32(code, load_addr, tmp_filename, method, padding_char, padding_size):
  if not isinstance(code, str):
    raise TypeError
  if not isinstance(method, (list, tuple)):
    raise TypeError
  if load_addr is None:
    load_addr = 0x8048000

  elf32_size = 0x54 + len(code) + padding_size
  elf32_header = get_elf32_header(elf32_size - 0x54, load_addr)
  assert len(elf32_header) == 0x54
  f = open(tmp_filename, 'wb')
  try:
    f.write(elf32_header)
    f.write(code)
    if padding_size > 0:  # Avoid UPX error: ': file is too small'.
      f.write(padding_char * padding_size)
  finally:
    f.close()
  os.chmod(tmp_filename, 0700)  # Avoid UPX error: ': file not executable'

  # -qqq is totally quiet, it doesn't even print the exception.
  # -qq prints one line with the sizes.
  cmd = (
      [(os.path.dirname(__file__) or '.') + '/tools/upx', '-qq'] +
      method +
      ['--', tmp_filename])
  print >>sys.stderr, 'info: running with padding_size=%d: %s' % (
      padding_size, ' ' .join(map(pipes.quote, cmd)))
  try:
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  except OSError:
    os.unlink(tmp_filename)
    raise RuntimeError('UPX not found: %x' % cmd[0])
  try:
    upx_stdout, upx_stderr = p.communicate('')
  finally:
    exit_code = p.wait()
  if exit_code:
    #assert 0, (exit_code, upx_stderr, os.stat(tmp_filename).st_size)
    os.unlink(tmp_filename)
    # 'upx: ...: IOException: file is too small -- skipped\n'
    # 'upx: ...: NotCompressibleException\n'
    # ': file is too small' in upx_stderr or  # We take care of this.
    if ': NotCompressibleException' in upx_stderr:
      return False, None
    if ': file is too large' in upx_stderr:
      return None, None
    sys.stderr.write(upx_stderr)
    raise RuntimeError('UPX failed with exit_code=0x%x.' % exit_code)
  # Don't print upx_stdout, it just contains statistics as a one-liner.
  sys.stderr.write(upx_stderr)  # !! Omit.
  return elf32_size, zlib.adler32(elf32_header)


def bmcompress32(code, load_addr, tmp_filename, method='--ultra-brute', signature_start_ofs_max=0):
  """!! write docstring"""
  if not isinstance(code, str):
    raise TypeError
  if load_addr is None:
    load_addr = 0x8048000

  if not method or method == '--none':
    return code  # Keep it uncompressed.
  #method = '--best --small'  # !!  --small also avoids some nops.
  #method = '--best'
  method = '--ultra-brute --small'  # !!
  #method = '--lzma --small'   # This can force LZMA.
  #method = '-9'
  method = ['-' * (1 + (arg not in '123456789')) + arg for arg in
            (arg.strip('-') for arg in method.replace(',', ' ').split()) if arg]
  # Example good: '--best'. Doesn't enable LZMA.
  # Example good: '--brute'. Also enables LZMA.
  # Example good: '--ultra-brute'. Also enables LZMA.
  # Example good: '--ultra-brute --lzma'.
  # !! Which one includes --lzma by default?
  # !! What is the minimum size for --lzma? (can we override with --lzma)?
  if not method:
    method.append('--ultra-brute')
  has_lzma = '--brute' in method or '--ultra-brute' in method or '--lzma' in method
  method[:] = [arg for arg in method if arg != '--small']
  if not has_lzma:
    # --small makes M_LZMA larger (!) by 23 bytes, so we don't apply it.
    # It also makes the M_NRV2A_LE16 a few dozen bytes smaller (avoiding NOPs etc),
    # so we apply it.
    method.append('--small')

  # Some golden values:
  #
  # * Input: 'X' * 0xfd1
  #   Output: .byte 201,168,170,146,88,0,96,20,84,0,0,0,0,0,0,0,144,255  (0x12 bytes)
  #   Compression: method=M_NRV2B_LE32, filter=0
  # * Input: 'X' * 0x14af
  #   Output: .byte 26,3,0,44,111,251,191,254,163,177,94,229,248,63,178,170,38,85,248,104,112,65,112,21,15,141,253,30,75,253,86,255,34,0 (0x22 bytes)
  #   Compression: method=M_LZMA filter=0
  #

  # !! Don't compress the entire thing, keep a few bytes in front of the signature intact. Header?
  # !! Use signature_start_ofs_max.

  padding_char = '\0'
  # Avoid the UPX error: ': file is too small' by adding
  # padding (for Packer::checkDefaultCompressionRatio), which is OK with
  # at least 4096 bytes or 6.25% gain.
  padding_size = 4096 - len(code) - 0x54
  if padding_size < 0:
    padding_size = 0
  elf32_size, elf32_header_adler32 = run_upx_elf32(
      code, load_addr, tmp_filename, method, padding_char, padding_size)
  if elf32_size is False:  # ': NotCompressibleException'.
    # Now we try to ensure a gain of >=4096 bytes, so UPX won't report
    # ': NotCompressibleException'. To do so, we add some trailing padding which is
    # very much compressible. We don't want to add a proportional padding, because
    # ultimately we want to keep uncompressible input unchanged.
    #
    # * With M_LZMA: decompressor + literal is <3404 bytes, 4096 + 3204 == 7600 bytes
    # * With others: decompressor + literal is  <704 bytes, 4096 +  704 == 4800 bytes
    padding_size = (7600, 4800)[not has_lzma]
    elf32_size, elf32_header_adler32 = run_upx_elf32(
        code, load_addr, tmp_filename, method, padding_char, padding_size)
  if not elf32_size:
    return code  # Keep it unchanged.

  # !! try different load_addr values

  # The upx binary calls upx_ucl_compress and upx_lzma_compress is called
  # with 3 different block sizes:
  #
  # * 0x54 (for the ELF32 header)
  # * 0x65e == 1630 this is the modified stub_i386_linux_elf_fold of uncompressed size sizeof(stub_i386_linux_elf_fold) - fold_hdrlen == 1758 - 128 == 1630
  #    buildLinuxLoader(
  #      stub_i386_linux_elf_entry, sizeof(stub_i386_linux_elf_entry),
  #      tmp,                       sizeof(stub_i386_linux_elf_fold),  ft );
  # * len(code) + padding_size

  data = open(tmp_filename, 'rb').read()
  i = 0
  ehdr_fields = (
      ('ei_mag', '4s'),
      ('ei_class', 'B'),
      ('ei_data', 'B'),
      ('ei_version', 'B'),
      ('e_osabi', 'B'),
      ('e_abiversion', 'B'),
      ('e_pad', '7s'),
      ('e_type', 'H'),
      ('e_machine', 'H'),
      ('e_version', 'L'),
      ('e_entry', 'L'),
      ('e_phoff', 'L'),
      ('e_shoff', 'L'),
      ('e_flags', 'L'),
      ('e_ehsize', 'H'),
      ('e_phentsize', 'H'),
      ('e_phnum', 'H'),
      ('e_shentsize', 'H'),
      ('e_shnum', 'H'),
      ('e_shstrndx', 'H'),
  )
  ehdr = parse_struct(ehdr_fields, data[i : i + 0x34])
  dump_struct(ehdr_fields, data[i : i + 0x34])  # !! Remove these calls.
  i += 0x34

  if ehdr['ei_mag'] != '\x7fELF':
    raise ValueError
  if ehdr['ei_class'] != 1:
    raise ValueError
  if ehdr['ei_data'] != 1:
    raise ValueError
  if ehdr['ei_version'] != 1:
    raise ValueError
  if ehdr['e_osabi'] not in (0, 3):  # 0: System V, 3: Linux.
    raise ValueError
  if ehdr['e_abiversion'] != 0:
    raise ValueError
  #if ehdr['e_pad'] != '\0\0\0\0\0\0\0':
  #  raise ValueError
  if ehdr['e_type'] != 2:
    raise ValueError('Expected an executable file.')
  if ehdr['e_machine'] != 3:  # x86.
    raise ValueError('Expected i386.')
  if ehdr['e_version'] != 1:
    raise ValueError
  if ehdr['e_ehsize'] != 0x34:
    raise ValueError
  if ehdr['e_phentsize'] != 0x20:
    raise ValueError
  if ehdr['e_flags'] != 0:
    raise ValueError
  if ehdr['e_shentsize'] not in (0, 0x28):
    raise ValueError
  if ehdr['e_shnum'] != 0:
    raise ValueError
  if ehdr['e_phnum'] not in (1, 2):
    raise ValueError(
        'Bad number of program header entries: %d' % ehdr['e_phnum'])
  if ehdr['e_phoff'] != i:
    raise ValueError

  phdr_fields = (  # ELF program header.
      ('p_type', 'L'),
      ('p_offset', 'L'),
      ('p_vaddr', 'L'),
      ('p_paddr', 'L'),
      ('p_filesz', 'L'),
      ('p_memsz', 'L'),
      ('p_flags', 'L'),
      ('p_align', 'L'),
  )
  phdr = None
  for phi in xrange(ehdr['e_phnum']):
    phdri = parse_struct(phdr_fields, data[i : i + 0x20])
    dump_struct(phdr_fields, data[i : i + 0x20])
    i += 0x20
    if phdri['p_memsz'] != 0:
      if phdr is not None:
        raise ValueError('Too many phdrs.')
      phdr = phdri
  elf_hdr_size = i
  print 'load_addr = 0x%x' % load_addr

  if phdr is None:
    raise ValueError('Missing phdr.')
  if phdr['p_type'] != 1:  # PT_LOAD.
    raise ValueError
  if phdr['p_memsz'] != phdr['p_filesz']:
    raise ValueError
  if phdr['p_vaddr'] != phdr['p_paddr']:
    raise ValueError
  if phdr['p_memsz'] == 0:
    raise ValueError
  if phdr['p_offset'] != 0:
    raise ValueError
  # !! Where is the base vaddr 0x00c01000 specified in the UPX sources? Can it change if we make the load_addr smaller?
  
  # Based on PackLinuxElf64::unpack in p_lx_elf.cpp and p_unix.h .
  # !! Check.
  l_info_fields = (  # 12-byte trailer in header for loader
      ('l_checksum', 'L'),  # TODO(pts): Check this. (It doesn't seem to match.)
      ('l_magic', '4s'),  # UPX_MAGIC_LE32 == 'UPX!'.
      ('l_lsize', 'H'),  # Decompressor stub size (?). 0x818 for ls.c32, 0x1200 for lua.c32.
      ('l_version', 'B'),  # Must be at least 10, getVersion() returns 13.
      ('l_format', 'B'),  # UPX_F_LINUX_ELF_i386 == 12.
  )
  l_info = parse_struct(l_info_fields, data[i : i + 12])
  dump_struct(l_info_fields, data[i : i + 12])  # !! Remove these calls.
  i += 12

  if l_info['l_magic'] != 'UPX!':
    raise ValueError('Bad l_magic.')
  if l_info['l_format'] != 12:
    raise ValueError('Bad l_format.')
  if not 10 <= l_info['l_version']  <= 14:
    raise ValueError('Unsupported l_version: %d' % l_info['l_version'])

  p_info_fields = (  # 12-byte packed program header.
      ('p_progid', 'L'),
      ('p_filesize', 'L'),
      ('p_blocksize', 'L'),
  )
  p_info = parse_struct(p_info_fields, data[i : i + 12])
  dump_struct(p_info_fields, data[i : i + 12])
  i += 12

  if p_info['p_progid']:
    raise ValueError('Bad p_progid.')
  if p_info['p_filesize'] != elf32_size:
    raise ValueError
  if p_info['p_blocksize'] != elf32_size:
    raise ValueError

  data_b_info = None
  c_adler32 = 1  # zlib.adler32('').
  # !! Properly parse the sections.
  for _ in xrange(ehdr['e_phnum']):  # Why 2 sections? The real data is in the 2nd one.
    # !! lots of filters (b_ftid) in filteri.cpp
    # Packer::getDecompressorSections (contains NRV and LZMA)
    # Method can be (for elf32):
    # * with --small: (!! which is the default? which one is smaller? should we specify --small? also for bmcompress.py?)
    #   * M_LZMA == 14: LZMA_ELF00,LZMA_DEC10,LZMA_DEC30.
    #   * M_NRV2B_LE32 == 2: N2BSMA10,N2BDEC10,N2BSMA20,N2BDEC20,N2BSMA30,N2BDEC30,N2BSMA40,N2BSMA50,N2BDEC50,N2BSMA60,N2BDEC60.
    #   * M_NRV2D_LE32 == 5: N2DSMA10,N2DDEC10,N2DSMA20,N2DDEC20,N2DSMA30,N2DDEC30,N2DSMA40,N2DSMA50,N2DDEC50,N2DSMA60,N2DDEC60.
    #   * M_NRV2E_LE32 == 8: N2ESMA10,N2EDEC10,N2ESMA20,N2EDEC20,N2ESMA30,N2EDEC30,N2ESMA40,N2ESMA50,N2EDEC50,N2ESMA60,N2EDEC60.
    # * without --small (fast) (!! why? 3 bytes extra output?):
    #   * M_LZMA == 14 (lua.c32): LZMA_ELF00,LZMA_DEC20,LZMA_DEC30.
    #   * M_NRV2B_LE32 == 2 (ls.c32): N2BFAS10,+80CXXXX,N2BFAS11,N2BDEC10,N2BFAS20,N2BDEC20,N2BFAS30,N2BDEC30,N2BFAS40,N2BFAS50,N2BDEC50,N2BFAS60,+40CXXXX,N2BFAS61,N2BDEC60.
    #   * M_NRV2D_LE32 == 5: N2DFAS10,+80CXXXX,N2DFAS11,N2DDEC10,N2DFAS20,N2DDEC20,N2DFAS30,N2DDEC30,N2DFAS40,N2DFAS50,N2DDEC50,N2DFAS60,+40CXXXX,N2DFAS61,N2DDEC60.
    #   * M_NRV2E_LE32 == 8: N2EFAS10,+80CXXXX,N2EFAS11,N2EDEC10,N2EFAS20,N2EDEC20,N2EFAS30,N2EDEC30,N2EFAS40,N2EFAS50,N2EDEC50,N2EFAS60,+40CXXXX,N2EFAS61,N2EDEC60.
    # PackLinuxElf32x86::addStubEntrySections (both b_method and b_ftid)
    #   LEXEC000 call main; decompress: ...
    #   LXUNF000?
    #   LXUNF002?
    #   MRUBYTE0?
    #   LXMRU005?
    #   LXMRU006?
    #   LXMRU007?
    #   LXUNF008?
    #   LXUNF010?
    #   LEXEC009?
    #   LEXEC010
    #   calls addLoader(getDecompressorSections(), NULL);
    #   LEXEC015
    #   LXUNF042?
    #   calls addFilter32(ft->id);? 
    #   LXMRU058?
    #   LXUNF035?
    #   LEXEC017? (if no filter)
    #   --- This is the end of the decompression code.
    #   IDENTSTR  '\n\0$Info: This file is packed with the UPX executable packer http://upx.sf.net $\n\0$Id: UPX ' ... '3.94 Copyright (C) 1996-2017 the UPX Team. All Rights Reserved. $\n\0'
    #   LEXEC020
    #   LUNMP000?
    #   LUNMP001?
    #   LEXEC025
    #   FOLDEXEC Patched and then compressed stub_i386_linux_elf_fold, without its first 128 bytes. The uncompressed version is typically 1630 bytes.
    b_info_fields = (  # 12-byte header before each compressed block.
        ('sz_unc', 'L'),  # Uncompressed size.
        ('sz_cpr', 'L'),  # Compressed size.
        ('b_method', 'B'),  # Compression algorithm.
        ('b_ftid', 'B'),  # Filter ID.
        ('b_cto8', 'B'),  # Filter parameter.
        ('b_unused', 'B'),
    )
    b_info = parse_struct(b_info_fields, data[i : i + 12])
    data_b_info = b_info  # The last.
    dump_struct(b_info_fields, data[i : i + 12])
    i += 12
    b_info['c_ofs'] = i  # Compressed data starts here.
    c_adler32 = zlib.adler32(buffer(data, i, b_info['sz_cpr']), c_adler32)
    i += b_info['sz_cpr']
  if data_b_info['sz_unc'] != elf32_size - 0x54:
    raise ValueError
  if data_b_info['sz_cpr'] >= data_b_info['sz_unc']:
    raise ValueError('Compression not effective, UPX should have failed already.')
  compressed_data = buffer(data, data_b_info['c_ofs'], data_b_info['sz_cpr'])

  i += (-i & 0x7)  # Round up to 16 bytes.
  # Loader starts here at i (with ofsa).
  ofsa, ofsb = struct.unpack('<LL', data[i : i + 8])
  i += 8
  loader_ofs = i
  sizea = i - ofsa
  print 'i = 0x%x' % i
  # !! What are these offsets? Who emits them?
  print 'ofsa = 0x%x' % ofsa
  print 'ofsb = 0x%x' % ofsb
  print 'sizea = 0x%x' % sizea
  if i != (ehdr['e_entry'] - phdr['p_vaddr']):
    raise ValueError(
        'Bad entry point: i=0x%x ofs=0x%x' %
        (i, ehdr['e_entry'] - phdr['p_vaddr']))
  if i != ofsb + 4:
    raise ValueError('Bad ofsb.')
  if not 0 <= sizea < 0x200:  # Typically 0x8c. Why?
    raise ValueError('Bad sizea.')
  if data[i] != '\xe8':
    raise ValueError('Bad loader start byte.')
  if data_b_info['b_ftid'] != 0 and data[i + 5] != '\xeb' or data[i + 6] > '\x7f':
    # This is the jump to the real decompress routine.
    raise ValueError('Bad decompress start byte.')
  if (i - 8) + l_info['l_lsize'] == len(data) - 36 - 12:  # !! Why occasionally 12?
    print 'FFF', tmp_filename

  if ((i - 8) + l_info['l_lsize'] != len(data) - 36 - 8 and
      (i - 8) + l_info['l_lsize'] != len(data) - 36 - 12):  # chain.c32
    raise ValueError('Bad l_lsize: 0x%x vs 0x%x' % ((i - 8) + l_info['l_lsize'], len(data) - 36 - 8))
  loader_data = data[i - 8 : i + l_info['l_lsize']]
  #print 'LOADER'
  ##i = 0
  #for l_size in xrange(4600, 4700):
  #  for j in xrange(-20, 200):
  #    loader_data = data[i + j : i + j + l_size]
  #    import zlib
  #    if (zlib.adler32(loader_data, 1) & 0xffffffff) == (l_info['l_checksum'] & 0xffffffff):
  #      print (l_size, j)  # !! l_checksum not found! Why??
  #print '/LOADER'
  i += l_info['l_lsize'] - 8
  i = len(data) - 36 - 8

  if data[i : i + 8] != 'UPX!\0\0\0\0':
    raise ValueError('Bad signature after loader.')
  i += 8

  # PackHeader::putPackHeader called from pack4().
  ph_fields = (  # PackHeader.
      ('ph_alignment', '<0s'),
      ('ph_magic', '4s'),
      ('ph_version', 'B'),
      ('ph_format', 'B'),
      ('ph_method', 'B'),
      ('ph_level', 'B'),  # Not stored anywhere else.
      ('ph_u_adler', 'L'),
      ('ph_c_adler', 'L'),
      ('ph_u_len', 'L'),
      ('ph_c_len', 'L'),
      ('ph_u_file_size', 'L'),
      ('ph_filter', 'B'),
      ('ph_filter_cto', 'B'),
      ('ph_n_mru1', 'B'),  # Not stored anywhere else.
      ('ph_dummy', 'B'),
  )
  ph = parse_struct(ph_fields, data[i : i + 32])
  dump_struct(ph_fields, data[i : i + 32])
  overlay_offset, = struct.unpack('<L', data[i + 32 : i + 36])
  print 'overlay_offset = 0x%x' % overlay_offset  # dump_struct. !!
  i += 36
  if i != len(data):
    raise ValueError('Expected EOF on compressed ELF32 executable.')

  if overlay_offset != elf_hdr_size + 12:
    raise ValueError
  if ph['ph_magic'] != 'UPX!':
    raise ValueError('Bad l_magic.')
  if ph['ph_version'] != l_info['l_version']:
    raise ValueError
  if ph['ph_format'] != l_info['l_format']:
    raise ValueError
  if ph['ph_method'] != data_b_info['b_method']:
    raise ValueError
  #if ph['ph_level'] != ...:  # Not stored anywhere else.
  #  raise ValueError
  if ph['ph_u_adler'] != (zlib.adler32(padding_char * padding_size, zlib.adler32(code, elf32_header_adler32)) & 0xffffffff):
    raise ValueError
  if ph['ph_c_adler'] != (c_adler32 & 0xffffffff):
    raise ValueError
  if ph['ph_u_len'] != data_b_info['sz_unc']:
    raise ValueError
  if ph['ph_c_len'] != len(compressed_data):
    raise ValueError
  if ph['ph_u_file_size'] != elf32_size:
    raise ValueError
  if ph['ph_filter'] != data_b_info['b_ftid']:
    raise ValueError
  if ph['ph_filter_cto'] != data_b_info['b_cto8']:
    raise ValueError
  #if ph['ph_n_mru1'] != ...:  # Not stored anywhere else.
  #  raise ValueError
  #os.unlink(tmp_filename)

  i = data.find('\n\0$Info: This file is packed with the UPX executable packer http://upx.sf.net $\n\0$Id: UPX ', loader_ofs)  # identbig.
  if i < 0:
    i = data.find(' the UPX Team. All Rights Reserved. http://upx.sf.net $\n\0', loader_ofs)  # identsmall.
    if i < 0:
      raise ValueError('UPX end-of-decompress signature not found.')
    if data[i - 23 : i - 4] != '\n$Id: UPX (C) 1996-':
      raise ValueError
  # It's important to crop at i now, because it is followed by the
  # compressed FOLDEXEC (stub_i386_linux_elf_fold), which is <1630 bytes
  # (less because of compression).
  loader_end_ofs = i
  decompress_ofs = loader_ofs + 7 + ord(data[loader_ofs + 6])

  if data_b_info['sz_cpr'] + (loader_end_ofs - loader_ofs) >= data_b_info['sz_unc']:
    raise ValueError('Compression not effective, UPX should have failed already.')

  # Fortunately the UPX decompressor code is position-independent.

  # !!Add 'UPX!' to the output binary.

  def to_byte(s):
    return '.byte %s\n' % ','.join(str(ord(c)) for c in s)
  # !! Emit padding_size.
  lxunfilter_idx = 0x2f  # !!
  decompress_idx = 0x39  # !!
  sz_unc_idx = 0x43  # !!
  assert data_b_info['b_ftid'] != 0  # !! shorter if no filter

  output = [
      '/* decompress_size = %d */\n' % (loader_end_ofs - loader_ofs - 7),
      '.text\n',
  ]
  if data_b_info['b_ftid'] != 0:
    output.extend((
        '.global smart_decompress\n',
        'smart_decompress:\n',
        # lxunfilter equ 0x2c
        # decompress equ 0x36
        # 00000000  E800000000        call dword 0x5
        '.byte 0xe8; .long 0\n'
        # .after_call_next:
        # 00000005  92                xchg eax,edx
        '.byte 0x92\n'
        # 00000006  58                pop eax
        '.byte 0x58\n'
        # 00000007  6A0B              push byte +0xb
        '.byte 0x6a, %d\n' % data_b_info['b_cto8'],
        # 00000009  053E000000        add eax,0x3e  # sz_unc - .after_call_next
        '.byte 0x05; .long %d\n' % (loader_end_ofs - loader_ofs - 7 + 0x38 - 0x5),
        # 0000000E  50                push eax
        '.byte 0x50\n'
        # 0000000F  52                push edx
        '.byte 0x52\n'
        # 00000010  680A000000        push dword 0xa
        '.byte 0x68; .long %d\n' % len(compressed_data),
        # 00000015  83C004            add eax,byte +0x4
        '.byte 0x83, 0xc0, 0x04\n'
        # 00000018  50                push eax
        '.byte 0x50\n'
        # 00000019  E81B000000        call dword 0x39  # decompress
        # decompress modifies its outs arg (and then it changes it back),
        # so we need to compile it with `gcc -Wl,-N' for a writable .text
        # section.
        '.byte 0xe8; .long %d\n' % (decompress_ofs - loader_ofs - 7 + 0x38 - 0x1e),
        # 0000001E  85C0              test eax,eax
        '.byte 0x85, 0xc0\n'
        # 00000020  7402              jz 0x24
        '.byte 0x74, 0x02\n'
        # 00000022  FA                cli
        '.byte 0xfa\n'
        # 00000023  F4                hlt
        '.byte 0xf4\n'
        # 00000024  58                pop eax
        '.byte 0x58\n'
        # 00000025  58                pop eax
        '.byte 0x58\n'
        # 00000026  58                pop eax
        '.byte 0x58\n'
        # 00000027  5A                pop edx
        '.byte 0x5a\n'
        # 00000028  FF32              push dword [edx]
        '.byte 0xff, 0x32\n'
        # 0000002A  50                push eax
        '.byte 0x50\n'
        # 0000002B  E808000000        call dword 0x38  # lxunfilter
        '.byte 0xe8; .long 8\n'
        # 00000030  58                pop eax
        '.byte 0x58\n'
        # 00000031  58                pop eax
        '.byte 0x58\n'
        # 00000032  58                pop eax
        '.byte 0x58\n'
        # 00000033  C3                ret
        '.byte 0xc3\n'
        # 00000034  ????????
        '.byte \'U\', \'P\', \'X\', \'~\'\n'
        # 00000038  (EOF)
    ))
  else:
    assert 000
  output.extend((
      '.global lxunfilter\n',
      'lxunfilter:  /* must come directly after the end of smart_decompress */\n',
      to_byte(data[loader_ofs + 7 : decompress_ofs]),  # !! Is .lstrip('\x90') safe here? .rstrip('\0') isn't safe, because it ruins the relative offsets.
      '.globl decompress\n',
      'decompress:\n',
      to_byte(data[decompress_ofs : loader_end_ofs]),
      '.globl sz_unc\n',
      'sz_unc:  /* must be directly in front of compressed_data */\n',
      '.long %d\n' % data_b_info['sz_unc'],
      '.globl compressed_data\n',
      'compressed_data:\n',
      to_byte(compressed_data),
      '.section .rodata\n',
      '.globl b_method\n',
      'b_method:\n',
      '.byte %d\n' % data_b_info['b_method'],
      '.globl b_ftid\n',
      'b_ftid:\n',
      '.byte %d\n' % data_b_info['b_ftid'],
      '.globl b_cto8\n',
      'b_cto8:\n',
      '.byte %d\n' % data_b_info['b_cto8'],
      '.globl sz_cpr\n',
      'sz_cpr:\n',
      '.long %d\n' % len(compressed_data),
  ))
  open('deco.s', 'w').write(''.join(output))
  open('deco.h', 'w').write(
      'void lxunfilter(char *p, unsigned s, unsigned cto8 /*, unsigned ftid */ );\n'
      'int decompress(const char *inp, unsigned ins, char *outp, unsigned *outs  /* , unsigned params */);\n'
      'void smart_decompress(char *outp) __attribute__((regparm(3)));\n'
      'extern const unsigned char b_method, b_ftid, b_cto8;\n'
      'extern unsigned sz_unc;\n'
      'extern const unsigned sz_cpr;\n'
      'extern const char compressed_data[];\n')

  # method=M_LZMA filter=0 decompress_size=2835
  # --small method=M_LZMA filter=0 decompress_size=2858
  # method=M_LZMA filter=0x49 decompress_size=2923
  # --small method=M_LZMA filter=0x49 decompress_size=2946  (strange, --small is larger)
  # method=M_NRV2B_LE32 filter=0x49 decompress_size=328
  # --small method=M_NRV2B_LE32 filter=0x49 decompress_size=297

  # !! Fail here if not compressible in the end.


def main(argv):
  for filename in argv[1:]:
    print >>sys.stderr, 'info: compressing: %s' % filename
    code = open(filename, 'rb').read()
    tmp_filename = filename + '.tmp'
    code = bmcompress32(code, None, tmp_filename)
  #open(tmp_filename, 'wb').write(code)


if __name__ == '__main__':
  sys.exit(main(sys.argv))
